from Crypto.PublicKey import RSA
from Crypto.Util.number import *
import math

_1_50 = 1 << 50  # 2**50 == 1,125,899,906,842,624
f = open('public.pem','r')
key = RSA.importKey(f.read())
print("n: ",key.n)
print("e: ",key.e)
n =  17729028558979019485846420034614601781855286885772116033115998289130663218793249135103097941406615594783564487056148202535602218241261076180277862184340050681277512936764254998557657989633659561175844653871375735119626199870178796372816549333367076487655787617921785826120525919291798195591267544750350222858119219959311035913906885739352404726672836723117136379411134589884489391116922923390687958161705756705708668649262568471831705504852664779788943978721769038284989250803324876493071615384204553854811020877754034576798208169454695001947778015807032019651748938505463608871771494765303144219873993106068807291321
e =  65537
# p = 133150398268195275743440564494273922289580211854275732500110288734747827954102678337833707292013932698242 219254 622842 845639 915924 282608 624204 786786 392336 964091 586374 322686 524012 967082 822794 190857 146515 192578 928726 013025 527238 404636 134021 379501 081455 477264 698849 928505026780491785694428836269895358616314275861
# d1 = 270519379266353654971182996393100108058887145975130323834108950503237304405042176710912888008401599017098196241148484101127641152955751349318367672983811445157354058574000259373447945277227513636203131877738922061120072628746796410772793221132598020776901408638201105118032957249977847560786541110370481145888875291199033155529042918341584215430563448481272203173949594730983862415382500318761737005992122872662902919713483505070902017255178979504538565676209912542304183145449515182157737085679914458318370094416192907469035936485568381249489265846880876751327478195606506383749202660562783530217647940950437268
# d2 = 270519379266353654971182996393100108058887145975130323834108950503237304405042176710912888008401599017098196241148484101127641152955751349318367672983811445157354058574000259373447945277227513636203131877738922061120072628746796410772793221132598020776901408638201105118032957249977847560786541110370481145888875291199033155529042918341584215430563448481272203173949594730983862415382500318761737005992122872662902919713483505070902017255178979504538565676209912542304183145449515182157737085679914458318370094416192907469035936485568381249489265846880876751327478195606506383749202660562783530217647940950437269
# d3 = 2434674413397182894740646967537900972529984313776172914506980554529135739645379590398215992075614391153883766170336356910148770376601762143865309056854303006416186527166002334361031507495047622725828186899650298550080653658721167696955138990193382186992112677743809946062296615249800628047078869993334330312999877620791298399761386265074257938875071036331449828565546352578854761738442502868855633053929105853966126277421351545638118155296610815540847091085889212880737648309045636639419633771119230124865330849745736167221323428370115431245403392621927890761947303760458557453742823945065051771958831468553935420
c = 5316023511767723681554876625599689220240019197295349694432925020790298468212539804790769912435131442622602753438222881080130876863449962984589722273061709740205966525154022903977264974516896392353624351445749655934551429624843710158328768754775469470800986263437806828123171984876649754969672119956666439483131644320647828724125814694857517289796708117148060056276238612321283549784948865979194592283751047450837970040429271585950515261301444053916923599464925671926051778057128687338358930426285217487854776229406228611180728357806661527583001060894431397795375210460132901262446672610074437051243211751937933974871
def isqrt(x):
    """Return the integer part of the square root of x, even for very
    large integer values."""
    if x < 0:
        raise ValueError('square root not defined for negative numbers')
    if x < _1_50:
        return int(math.sqrt(x))  # use math's sqrt() for small parameters
    n = int(x)
    if n <= 1:
        return n  # handle sqrt(0)==0, sqrt(1)==1
    # Make a high initial estimate of the result (a little lower is slower!!!)
    r = 1 << ((n.bit_length() + 1) >> 1)
    while True:
        newr = (r + n // r) >> 1  # next estimate by Newton-Raphson
        if newr >= r:
            return r
        r = newr
# res = isqrt(n)
# print(res)
p = 133150398268195275743440564494273922289580211854275732500110288734747827954102678337833707292013932698242219254622842845639915924282608624204786786392336964091586374322686524012967082822794190857146515192578928726013025527238404636134021379501081455477264698849928505026780491785694428836269895358616314275861
phi_n = p*(p-1)
d = inverse(e,phi_n)
print(d)
m = pow(c,d,n)
print(long_to_bytes(m))